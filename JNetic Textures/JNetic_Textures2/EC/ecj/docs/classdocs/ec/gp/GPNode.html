<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_16) on Mon Jul 13 16:45:50 EDT 2009 -->
<TITLE>
GPNode
</TITLE>

<META NAME="keywords" CONTENT="ec.gp.GPNode class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="GPNode";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../ec/gp/GPNodeBuilder.html" title="class in ec.gp"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?ec/gp/GPNode.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GPNode.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
ec.gp</FONT>
<BR>
Class GPNode</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>ec.gp.GPNode</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A>, <A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A>, <A HREF="../../ec/Setup.html" title="interface in ec">Setup</A>, java.io.Serializable, java.lang.Cloneable</DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../ec/gp/ADF.html" title="class in ec.gp">ADF</A>, <A HREF="../../ec/gp/ADFArgument.html" title="class in ec.gp">ADFArgument</A>, <A HREF="../../ec/gp/ERC.html" title="class in ec.gp">ERC</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public abstract class <B>GPNode</B><DT>extends java.lang.Object<DT>implements <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A>, <A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></DL>
</PRE>

<P>
GPNode is a GPNodeParent which is the abstract superclass of
 all GP function nodes in trees.  GPNode contains quite a few functions
 for cloning subtrees in special ways, counting the number of nodes
 in subtrees in special ways, and finding specific nodes in subtrees.

 GPNode's lightClone() method does not clone its children (it copies the
 array, but that's it).  If you want to deep-clone a tree or subtree, you
 should use one of the cloneReplacing(...) methods instead.

 <p>GPNodes contain a number of important items:
 <ul><li>A <i>constraints</i> object which defines the name of the node,
 its arity, and its type constraints. This
 object is shared with all GPNodes of the same function name/arity/returntype/childtypes.
 <li>A <i>parent</i>.  This is either another GPNode, or (if this node
 is the root) a GPTree.
 <li>Zero or more <i>children</i>, which are GPNodes.
 <li>An argument position in its parent.
 </ul>


 <p>In addition to serialization for checkpointing, GPNodes may read and write themselves to streams in three ways.

 <ul>
 <li><b>writeNode(...,DataOutput)/readNode(...,DataInput)</b>&nbsp;&nbsp;&nbsp;This method
 transmits or receives a GPNode in binary.  It is the most efficient approach to sending
 GPNodes over networks, etc.  The default versions of writeNode/readNode both generate errors.
 GPNode subclasses should override them to provide more functionality, particularly if you're planning on using
 ECJ in a distributed fashion.  Both of these functions are called by GPNode's readRootedTree/writeRootedTree
 respectively, which handle the reading/printing of the trees as a whole.

 <li><b>printNode(...,PrintWriter)/readNode(...,LineNumberReader)</b>&nbsp;&nbsp;&nbsp;This
 approach transmits or receives a GPNode in text encoded such that the GPNode is largely readable
 by humans but can be read back in 100% by ECJ as well.  To do this, these methods will typically encode numbers
 using the <tt>ec.util.Code</tt> class.  These methods are mostly used to write out populations to
 files for inspection, slight modification, then reading back in later on.  Both of these functions are called by GPNode's readRootedTree/writeRootedTree
 respectively, which handle the reading/printing of the trees as a whole.  Notably readRootedNode
 will try to determine what kind of node is next, then call <b>readNode</b> on the prototype for that
 node to generate the node.  <b>printNode</b> by default calls toString() and
 prints the result, though subclasses often override this to provide additional functionality (notably
 ERCs).

 <li><b>printNodeForHumans(...,PrintWriter)</b>&nbsp;&nbsp;&nbsp;This
 approach prints a GPNode in a fashion intended for human consumption only.
 <b>printNodeForHumans</b> by default calls toStringForHumans() (which by default calls toString()) and
 prints the result.  printNodeForHumans is called by <b>printRootedTreeForHumans</b>, which handles
 printing of the entire GPNode tree.
 </ul>


 <p><b>Parameters</b><br>
 <table>
 <tr><td valign=top><i>base</i>.<tt>nc</tt><br>
 <font size=-1>String</font></td>
 <td valign=top>(name of the node constraints for the GPNode)</td></tr>
 </table>

 <p><b>Default Base</b><br>
 gp.node
<P>

<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../serialized-form.html#ec.gp.GPNode">Serialized Form</A></DL>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#argposition">argposition</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The argument position of the child in its parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#children">children</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#constraints">constraints</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GPNode's constraints.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#GPNODEPRINTTAB">GPNODEPRINTTAB</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#MAXPRINTBYTES">MAXPRINTBYTES</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_ALL">NODESEARCH_ALL</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_CUSTOM">NODESEARCH_CUSTOM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_NONTERMINALS">NODESEARCH_NONTERMINALS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#NODESEARCH_TERMINALS">NODESEARCH_TERMINALS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#P_NODE">P_NODE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#P_NODECONSTRAINTS">P_NODECONSTRAINTS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#parent">parent</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The GPNode's parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#SITUATION_MUTATION">SITUATION_MUTATION</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#SITUATION_NEWIND">SITUATION_NEWIND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#GPNode()">GPNode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#atDepth()">atDepth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the depth at which I appear in the tree, which is a value >= 0.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#checkConstraints(ec.EvolutionState, int, ec.gp.GPIndividual, ec.util.Parameter)">checkConstraints</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                 int&nbsp;tree,
                 <A HREF="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</A>&nbsp;typicalIndividual,
                 <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A>&nbsp;individualBase)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;You ought to override this method to check to make sure that the
        constraints are valid as best you can tell.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#clone()">clone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacing()">cloneReplacing</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacing(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacing</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newSubtrees,
               <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldSubtrees)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacing(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacing</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
               <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomic(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacingAtomic</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newNodes,
                     <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldNodes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with each node in oldNodes[] respectively
        (which may or may not be in the subtree) replaced with
        the equivalent
        nodes in newNodes[] (and not clones).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingAtomic(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingAtomic</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode,
                     <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Clones a new subtree, but with the single node oldNode 
        (which may or may not be in the subtree) 
        replaced with a newNode (not a clone of newNode).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#cloneReplacingNoSubclone(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingNoSubclone</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                         <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNodeConstraints.html" title="class in ec.gp">GPNodeConstraints</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#constraints(ec.gp.GPInitializer)">constraints</A></B>(<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</A>&nbsp;initializer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#contains(ec.gp.GPNode)">contains</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;subnode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the subtree rooted at this node contains subnode.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#defaultBase()">defaultBase</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The default base for GPNodes -- defined even though
        GPNode is abstract so you don't have to in subclasses.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#depth()">depth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the depth of the tree, which is a value >= 1.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#errorInfo()">errorInfo</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A convenience function for identifying a GPNode in an error message</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#eval(ec.EvolutionState, int, ec.gp.GPData, ec.gp.ADFStack, ec.gp.GPIndividual, ec.Problem)">eval</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
     int&nbsp;thread,
     <A HREF="../../ec/gp/GPData.html" title="class in ec.gp">GPData</A>&nbsp;input,
     <A HREF="../../ec/gp/ADFStack.html" title="class in ec.gp">ADFStack</A>&nbsp;stack,
     <A HREF="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</A>&nbsp;individual,
     <A HREF="../../ec/Problem.html" title="class in ec">Problem</A>&nbsp;problem)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Evaluates the node with the given thread, state, individual, problem, and stack.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#lightClone()">lightClone</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#makeCTree(boolean, boolean, boolean)">makeCTree</A></B>(boolean&nbsp;parentMadeParens,
          boolean&nbsp;printTerminalsAsVariables,
          boolean&nbsp;useOperatorForm)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Producess a String consisting of the tree in pseudo-C form, given that the parent already will wrap the
        expression in parentheses (or not).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#makeGraphvizSubtree(java.lang.String)">makeGraphvizSubtree</A></B>(java.lang.String&nbsp;prefix)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Produces the inner code for a graphviz subtree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#makeGraphvizTree()">makeGraphvizTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Produces the Graphviz code for a Graphviz tree of the subtree rooted at this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#makeLatexTree()">makeLatexTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Produces the LaTeX code for a LaTeX tree of the subtree rooted at this node, using the <tt>epic</tt>
        and <tt>fancybox</tt> packages, as described in sections 10.5.2 (page 307) 
        and 10.1.3 (page 278) of <i>The LaTeX Companion</i>, respectively.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#makeLispTree()">makeLispTree</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Produces a tree for human consumption in Lisp form similar to that generated by printTreeForHumans().</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeEquals(ec.gp.GPNode)">nodeEquals</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if I am the "genetically" identical to this node, and our
        children arrays are the same length, though
        we may have different parents and children.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeEquivalentTo(ec.gp.GPNode)">nodeEquivalentTo</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if I and the provided node are the same kind of
        node -- that is, we could have both been cloned() and reset() from
        the same prototype node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeHashCode()">nodeHashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a hashcode usually associated with all nodes that are 
        equal to you (using nodeEquals(...)).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#nodeInPosition(int, ec.gp.GPNodeGatherer, int)">nodeInPosition</A></B>(int&nbsp;p,
               <A HREF="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</A>&nbsp;g,
               int&nbsp;nodesearch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the p'th node, constrained by nodesearch,
        in the subtree for which this GPNode is root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#numNodes(ec.gp.GPNodeGatherer)">numNodes</A></B>(<A HREF="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</A>&nbsp;g)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of nodes, constrained by g.test(...)
        in the subtree for which this GPNode is root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#numNodes(int)">numNodes</A></B>(int&nbsp;nodesearch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the number of nodes, constrained by nodesearch,
        in the subtree for which this GPNode is root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#parentType(ec.gp.GPInitializer)">parentType</A></B>(<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</A>&nbsp;initializer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the argument type of the slot that I fit into in my parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#pathLength(int)">pathLength</A></B>(int&nbsp;nodesearch)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the path length of the tree, which is the sum of all paths from all nodes to the root.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printNode(ec.EvolutionState, int, int)">printNode</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
          int&nbsp;log,
          int&nbsp;verbosity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printNode(ec.EvolutionState, java.io.PrintWriter)">printNode</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
          java.io.PrintWriter&nbsp;writer)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printNodeForHumans(ec.EvolutionState, int, int)">printNodeForHumans</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                   int&nbsp;log,
                   int&nbsp;verbosity)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out a human-readable and Lisp-like atom for the node, 
        and returns the number of bytes in the string that you sent
        to the log (use print(),
        not println()).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printRootedTree(ec.EvolutionState, int, int, int)">printRootedTree</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                int&nbsp;log,
                int&nbsp;verbosity,
                int&nbsp;printbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printRootedTree(ec.EvolutionState, java.io.PrintWriter, int)">printRootedTree</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                java.io.PrintWriter&nbsp;writer,
                int&nbsp;printbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#printRootedTreeForHumans(ec.EvolutionState, int, int, int, int)">printRootedTreeForHumans</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                         int&nbsp;log,
                         int&nbsp;verbosity,
                         int&nbsp;tablevel,
                         int&nbsp;printbytes)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Prints out the tree in a readable Lisp-like multi-line fashion.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#readNode(ec.util.DecodeReturn)">readNode</A></B>(<A HREF="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</A>&nbsp;dret)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the node symbol,
        advancing the DecodeReturn to the first character in the string
        beyond the node symbol, and returns a new, empty GPNode of the
        appropriate class representing that symbol, else null if the
        node symbol is not of the correct type for your GPNode class.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#readNode(ec.EvolutionState, java.io.DataInput)">readNode</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
         java.io.DataInput&nbsp;dataInput)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override this to read any additional node-specific information from dataInput besides: the number of arguments,
        the specific node class, the children, and the parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#readRootedTree(ec.EvolutionState, java.io.DataInput, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int)">readRootedTree</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
               java.io.DataInput&nbsp;dataInput,
               <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A>&nbsp;expectedType,
               <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
               <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A>&nbsp;parent,
               int&nbsp;argposition)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#readRootedTree(int, ec.util.DecodeReturn, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int, ec.EvolutionState)">readRootedTree</A></B>(int&nbsp;linenumber,
               <A HREF="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</A>&nbsp;dret,
               <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A>&nbsp;expectedType,
               <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
               <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A>&nbsp;parent,
               int&nbsp;argposition,
               <A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reads the node and its children from the form printed out by printRootedTree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#replaceWith(ec.gp.GPNode)">replaceWith</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Replaces the node with another node in its position in the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#resetNode(ec.EvolutionState, int)">resetNode</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
          int&nbsp;thread)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Starts a node in a new life immediately after it has been cloned.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#rootedTreeEquals(ec.gp.GPNode)">rootedTreeEquals</A></B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if the two rooted trees are "genetically" equal, though
        they may have different parents.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#rootedTreeHashCode()">rootedTreeHashCode</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a hashcode associated with all the nodes in the tree.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#rootParent()">rootParent</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the root ancestor of this node.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
      <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A>&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets up a <i>prototypical</i> GPNode with those features all nodes of that
        prototype share, and nothing more.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#swapCompatibleWith(ec.gp.GPInitializer, ec.gp.GPNode)">swapCompatibleWith</A></B>(<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</A>&nbsp;initializer,
                   <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns true if I can swap into node's position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#toString()">toString</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Lisp-like atom for the node which can be read in again by computer.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#toStringForError()">toStringForError</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a description of the node that can make it easy to identify
        in error messages (by default, at least its name and the tree it's found in).</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#toStringForHumans()">toStringForHumans</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a Lisp-like atom for the node which is intended for human
        consumption, and not to be read in again.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#verify(ec.EvolutionState, ec.gp.GPFunctionSet, int)">verify</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
       <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
       int&nbsp;index)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Verification of validity of the node in the tree -- strictly for debugging purposes only</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#writeNode(ec.EvolutionState, java.io.DataOutput)">writeNode</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
          java.io.DataOutput&nbsp;dataOutput)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Override this to write any additional node-specific information to dataOutput besides: the number of arguments, 
        the specific node class, the children, and the parent.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../ec/gp/GPNode.html#writeRootedTree(ec.EvolutionState, ec.gp.GPType, ec.gp.GPFunctionSet, java.io.DataOutput)">writeRootedTree</A></B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A>&nbsp;expectedType,
                <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
                java.io.DataOutput&nbsp;dataOutput)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="P_NODE"><!-- --></A><H3>
P_NODE</H3>
<PRE>
public static final java.lang.String <B>P_NODE</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.P_NODE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="P_NODECONSTRAINTS"><!-- --></A><H3>
P_NODECONSTRAINTS</H3>
<PRE>
public static final java.lang.String <B>P_NODECONSTRAINTS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.P_NODECONSTRAINTS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="GPNODEPRINTTAB"><!-- --></A><H3>
GPNODEPRINTTAB</H3>
<PRE>
public static final java.lang.String <B>GPNODEPRINTTAB</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.GPNODEPRINTTAB">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MAXPRINTBYTES"><!-- --></A><H3>
MAXPRINTBYTES</H3>
<PRE>
public static final int <B>MAXPRINTBYTES</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.MAXPRINTBYTES">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NODESEARCH_ALL"><!-- --></A><H3>
NODESEARCH_ALL</H3>
<PRE>
public static final int <B>NODESEARCH_ALL</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.NODESEARCH_ALL">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NODESEARCH_TERMINALS"><!-- --></A><H3>
NODESEARCH_TERMINALS</H3>
<PRE>
public static final int <B>NODESEARCH_TERMINALS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.NODESEARCH_TERMINALS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NODESEARCH_NONTERMINALS"><!-- --></A><H3>
NODESEARCH_NONTERMINALS</H3>
<PRE>
public static final int <B>NODESEARCH_NONTERMINALS</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.NODESEARCH_NONTERMINALS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="NODESEARCH_CUSTOM"><!-- --></A><H3>
NODESEARCH_CUSTOM</H3>
<PRE>
public static final int <B>NODESEARCH_CUSTOM</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.NODESEARCH_CUSTOM">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SITUATION_NEWIND"><!-- --></A><H3>
SITUATION_NEWIND</H3>
<PRE>
public static final int <B>SITUATION_NEWIND</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.SITUATION_NEWIND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SITUATION_MUTATION"><!-- --></A><H3>
SITUATION_MUTATION</H3>
<PRE>
public static final int <B>SITUATION_MUTATION</B></PRE>
<DL>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#ec.gp.GPNode.SITUATION_MUTATION">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="parent"><!-- --></A><H3>
parent</H3>
<PRE>
public <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A> <B>parent</B></PRE>
<DL>
<DD>The GPNode's parent.  4 bytes.  :-(  But it really helps simplify breeding.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="children"><!-- --></A><H3>
children</H3>
<PRE>
public <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[] <B>children</B></PRE>
<DL>
<DL>
</DL>
</DL>
<HR>

<A NAME="argposition"><!-- --></A><H3>
argposition</H3>
<PRE>
public byte <B>argposition</B></PRE>
<DL>
<DD>The argument position of the child in its parent. 
        This is a byte to save space (GPNode is the critical object space-wise) -- 
        besides, how often do you have 256 children? You can change this to a short
        or int easily if you absolutely need to.  It's possible to eliminate even
        this and have the child find itself in its parent, but that's an O(children[])
        operation, and probably not inlinable, so I figure a byte is okay.
<P>
<DL>
</DL>
</DL>
<HR>

<A NAME="constraints"><!-- --></A><H3>
constraints</H3>
<PRE>
public byte <B>constraints</B></PRE>
<DL>
<DD>The GPNode's constraints.  This is a byte to save space -- how often do
        you have 256 different GPNodeConstraints?  Well, I guess it's not infeasible.
        You can increase this to an int without much trouble.  You typically 
        shouldn't access the constraints through this variable -- use the constraints(state)
        method instead.
<P>
<DL>
</DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="GPNode()"><!-- --></A><H3>
GPNode</H3>
<PRE>
public <B>GPNode</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="constraints(ec.gp.GPInitializer)"><!-- --></A><H3>
constraints</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNodeConstraints.html" title="class in ec.gp">GPNodeConstraints</A> <B>constraints</B>(<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</A>&nbsp;initializer)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="defaultBase()"><!-- --></A><H3>
defaultBase</H3>
<PRE>
public <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A> <B>defaultBase</B>()</PRE>
<DL>
<DD>The default base for GPNodes -- defined even though
        GPNode is abstract so you don't have to in subclasses.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../ec/Prototype.html#defaultBase()">defaultBase</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="checkConstraints(ec.EvolutionState, int, ec.gp.GPIndividual, ec.util.Parameter)"><!-- --></A><H3>
checkConstraints</H3>
<PRE>
public void <B>checkConstraints</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                             int&nbsp;tree,
                             <A HREF="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</A>&nbsp;typicalIndividual,
                             <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A>&nbsp;individualBase)</PRE>
<DL>
<DD>You ought to override this method to check to make sure that the
        constraints are valid as best you can tell.  Things you might
        check for:

        <ul>
        <li> children.length is correct
        <li> certain arguments in constraints.childtypes are 
        swap-compatible with each other
        <li> constraints.returntype is swap-compatible with appropriate 
        arguments in constraints.childtypes
        </ul>

        You can't check for everything, of course, but you might try some
        obvious checks for blunders.  The default version of this method
        is empty for now, but you should still call super.checkConstraints(state)
        just to be certain.

        The ultimate caller of this method must guarantee that he will eventually
        call state.output.exitIfErrors(), so you can freely use state.output.error
        instead of state.output.fatal(), which will help a lot.

        Warning: this method may get called more than once.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="setup(ec.EvolutionState, ec.util.Parameter)"><!-- --></A><H3>
setup</H3>
<PRE>
public void <B>setup</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                  <A HREF="../../ec/util/Parameter.html" title="class in ec.util">Parameter</A>&nbsp;base)</PRE>
<DL>
<DD>Sets up a <i>prototypical</i> GPNode with those features all nodes of that
        prototype share, and nothing more.  So no filled-in children, 
        no argposition, no parent.  Yet.

        This must be called <i>after</i> the GPTypes and GPNodeConstraints 
        have been set up.  Presently they're set up in GPInitializer,
        which gets called before this does, so we're safe. 

        You should override this if you need to load some special features on
        a per-function basis.  Note that base hangs off of a function set, so
        this method may get called for different instances in the same GPNode
        class if they're being set up as prototypes for different GPFunctionSets.

        If you absolutely need some global base, then you should use something
        hanging off of GPDefaults.base().

        The ultimate caller of this method must guarantee that he will eventually
        call state.output.exitIfErrors(), so you can freely use state.output.error
        instead of state.output.fatal(), which will help a lot.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../ec/Prototype.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></CODE><DT><B>Specified by:</B><DD><CODE><A HREF="../../ec/Setup.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</A></CODE> in interface <CODE><A HREF="../../ec/Setup.html" title="interface in ec">Setup</A></CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="parentType(ec.gp.GPInitializer)"><!-- --></A><H3>
parentType</H3>
<PRE>
public final <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A> <B>parentType</B>(<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</A>&nbsp;initializer)</PRE>
<DL>
<DD>Returns the argument type of the slot that I fit into in my parent.  
        If I'm the root, returns the treetype of the GPTree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="verify(ec.EvolutionState, ec.gp.GPFunctionSet, int)"><!-- --></A><H3>
verify</H3>
<PRE>
public final int <B>verify</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                        <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
                        int&nbsp;index)</PRE>
<DL>
<DD>Verification of validity of the node in the tree -- strictly for debugging purposes only
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="swapCompatibleWith(ec.gp.GPInitializer, ec.gp.GPNode)"><!-- --></A><H3>
swapCompatibleWith</H3>
<PRE>
public final boolean <B>swapCompatibleWith</B>(<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</A>&nbsp;initializer,
                                        <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if I can swap into node's position.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="numNodes(ec.gp.GPNodeGatherer)"><!-- --></A><H3>
numNodes</H3>
<PRE>
public int <B>numNodes</B>(<A HREF="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</A>&nbsp;g)</PRE>
<DL>
<DD>Returns the number of nodes, constrained by g.test(...)
        in the subtree for which this GPNode is root.  This might
        be sped up by caching the value.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="numNodes(int)"><!-- --></A><H3>
numNodes</H3>
<PRE>
public int <B>numNodes</B>(int&nbsp;nodesearch)</PRE>
<DL>
<DD>Returns the number of nodes, constrained by nodesearch,
        in the subtree for which this GPNode is root.
        This might be sped up by cacheing the value somehow.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="depth()"><!-- --></A><H3>
depth</H3>
<PRE>
public int <B>depth</B>()</PRE>
<DL>
<DD>Returns the depth of the tree, which is a value >= 1.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="pathLength(int)"><!-- --></A><H3>
pathLength</H3>
<PRE>
public int <B>pathLength</B>(int&nbsp;nodesearch)</PRE>
<DL>
<DD>Returns the path length of the tree, which is the sum of all paths from all nodes to the root.   O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="atDepth()"><!-- --></A><H3>
atDepth</H3>
<PRE>
public int <B>atDepth</B>()</PRE>
<DL>
<DD>Returns the depth at which I appear in the tree, which is a value >= 0. O(ln n) avg.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeInPosition(int, ec.gp.GPNodeGatherer, int)"><!-- --></A><H3>
nodeInPosition</H3>
<PRE>
public int <B>nodeInPosition</B>(int&nbsp;p,
                          <A HREF="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</A>&nbsp;g,
                          int&nbsp;nodesearch)</PRE>
<DL>
<DD>Returns the p'th node, constrained by nodesearch,
        in the subtree for which this GPNode is root.
        Use numNodes(nodesearch) to determine the total number.  Or if
        you used numNodes(g), then when
        nodesearch == NODESEARCH_CUSTOM, g.test(...) is used
        as the constraining predicate.
        p ranges from 0 to this number minus 1. O(n). The
        resultant node is returned in <i>g</i>.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rootParent()"><!-- --></A><H3>
rootParent</H3>
<PRE>
public <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A> <B>rootParent</B>()</PRE>
<DL>
<DD>Returns the root ancestor of this node.  O(ln n) average case,
        O(n) worst case.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="contains(ec.gp.GPNode)"><!-- --></A><H3>
contains</H3>
<PRE>
public boolean <B>contains</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;subnode)</PRE>
<DL>
<DD>Returns true if the subtree rooted at this node contains subnode.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="resetNode(ec.EvolutionState, int)"><!-- --></A><H3>
resetNode</H3>
<PRE>
public void <B>resetNode</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                      int&nbsp;thread)</PRE>
<DL>
<DD>Starts a node in a new life immediately after it has been cloned.
        The default version of this function does nothing.  The purpose of
        this function is to give ERCs a chance to set themselves to a new
        random value after they've been cloned from the prototype.
        You should not assume that the node is properly connected to other
        nodes in the tree at the point this method is called.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="errorInfo()"><!-- --></A><H3>
errorInfo</H3>
<PRE>
public java.lang.String <B>errorInfo</B>()</PRE>
<DL>
<DD>A convenience function for identifying a GPNode in an error message
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="lightClone()"><!-- --></A><H3>
lightClone</H3>
<PRE>
public <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>lightClone</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="clone()"><!-- --></A><H3>
clone</H3>
<PRE>
public java.lang.Object <B>clone</B>()</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  The result has everything set except for the root
        node's parent and argposition.  This method is identical to
        cloneReplacing for historical reasons, except that it returns
        the object as an Object, not a GPNode.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../ec/Prototype.html#clone()">clone</A></CODE> in interface <CODE><A HREF="../../ec/Prototype.html" title="interface in ec">Prototype</A></CODE><DT><B>Overrides:</B><DD><CODE>clone</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacing()"><!-- --></A><H3>
cloneReplacing</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacing</B>()</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  The result has everything set except for the root
        node's parent and argposition.  This method is identical to
        cloneReplacing for historical reasons, except that it returns
        the object as a GPNode, not an Object.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacing(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacing</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacing</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                                   <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If the node oldSubtree is located somewhere in this
        tree, then its subtree is replaced with a deep-cloned copy of
        newSubtree.  The result has everything set except for the root
        node's parent and argposition.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingNoSubclone(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingNoSubclone</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingNoSubclone</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newSubtree,
                                             <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldSubtree)</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If the node oldSubtree is located somewhere in this
        tree, then its subtree is replaced with
        newSubtree (<i>not</i> a copy of newSubtree).  
        The result has everything set except for the root
        node's parent and argposition.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacing(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacing</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacing</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newSubtrees,
                                   <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldSubtrees)</PRE>
<DL>
<DD>Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If a node in oldSubtrees is located somewhere in this
        tree, then its subtree is replaced with a deep-cloned copy of the
        subtree rooted at its equivalent number in 
        newSubtrees.  The result has everything set except for the root
        node's parent and argposition.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomic(ec.gp.GPNode, ec.gp.GPNode)"><!-- --></A><H3>
cloneReplacingAtomic</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingAtomic</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode,
                                         <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;oldNode)</PRE>
<DL>
<DD>Clones a new subtree, but with the single node oldNode 
        (which may or may not be in the subtree) 
        replaced with a newNode (not a clone of newNode).  
        These nodes should be
        type-compatible both in argument and return types, and should have
        the same number of arguments obviously.  This function will <i>not</i>
        check for this, and if they are not the result is undefined.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="cloneReplacingAtomic(ec.gp.GPNode[], ec.gp.GPNode[])"><!-- --></A><H3>
cloneReplacingAtomic</H3>
<PRE>
public final <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>cloneReplacingAtomic</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;newNodes,
                                         <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>[]&nbsp;oldNodes)</PRE>
<DL>
<DD>Clones a new subtree, but with each node in oldNodes[] respectively
        (which may or may not be in the subtree) replaced with
        the equivalent
        nodes in newNodes[] (and not clones).  
        The length of oldNodes[] and newNodes[] should
        be the same of course.  These nodes should be
        type-compatible both in argument and return types, and should have
        the same number of arguments obviously.  This function will <i>not</i>
        check for this, and if they are not the result is undefined.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="replaceWith(ec.gp.GPNode)"><!-- --></A><H3>
replaceWith</H3>
<PRE>
public final void <B>replaceWith</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;newNode)</PRE>
<DL>
<DD>Replaces the node with another node in its position in the tree. 
        newNode should already have been cloned and ready to go.
        We presume that the other node is type-compatible and
        of the same arity (these things aren't checked).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeEquivalentTo(ec.gp.GPNode)"><!-- --></A><H3>
nodeEquivalentTo</H3>
<PRE>
public boolean <B>nodeEquivalentTo</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if I and the provided node are the same kind of
        node -- that is, we could have both been cloned() and reset() from
        the same prototype node.  The default form of this function returns
        true if I and the node have the same class, the same length children
        array, and the same constraints.  You may wish to override this in
        certain circumstances.   Here's an example of how nodeEquivalentTo(node)
        differs from nodeEquals(node): two ERCs, both of
        the same class, but one holding '1.23' and the other holding '2.45', which
        came from the same prototype node in the same function set.
        They should NOT be nodeEquals(...) but *should* be nodeEquivalent(...).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeHashCode()"><!-- --></A><H3>
nodeHashCode</H3>
<PRE>
public int <B>nodeHashCode</B>()</PRE>
<DL>
<DD>Returns a hashcode usually associated with all nodes that are 
        equal to you (using nodeEquals(...)).  The default form
        of this method returns the hashcode of the node's class.
        ERCs in particular probably will want to override this method.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rootedTreeHashCode()"><!-- --></A><H3>
rootedTreeHashCode</H3>
<PRE>
public int <B>rootedTreeHashCode</B>()</PRE>
<DL>
<DD>Returns a hashcode associated with all the nodes in the tree.  
        The default version adds the hash of the node plus its child
        trees, rotated one-off each time, which seems reasonable.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="nodeEquals(ec.gp.GPNode)"><!-- --></A><H3>
nodeEquals</H3>
<PRE>
public boolean <B>nodeEquals</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if I am the "genetically" identical to this node, and our
        children arrays are the same length, though
        we may have different parents and children.  The default form
        of this method simply calls the much weaker nodeEquivalentTo(node).  
        You may need to override this to perform exact comparisons, if you're
        an ERC, ADF, or ADM for example.  Here's an example of how nodeEquivalentTo(node)
        differs from nodeEquals(node): two ERCs, both of
        the same class, but one holding '1.23' and the other holding '2.45', which
        came from the same prototype node in the same function set.
        They should NOT be nodeEquals(...) but *should* be nodeEquivalent(...).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="rootedTreeEquals(ec.gp.GPNode)"><!-- --></A><H3>
rootedTreeEquals</H3>
<PRE>
public boolean <B>rootedTreeEquals</B>(<A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A>&nbsp;node)</PRE>
<DL>
<DD>Returns true if the two rooted trees are "genetically" equal, though
        they may have different parents.  O(n).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printNodeForHumans(ec.EvolutionState, int, int)"><!-- --></A><H3>
printNodeForHumans</H3>
<PRE>
public int <B>printNodeForHumans</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                              int&nbsp;log,
                              int&nbsp;verbosity)</PRE>
<DL>
<DD>Prints out a human-readable and Lisp-like atom for the node, 
        and returns the number of bytes in the string that you sent
        to the log (use print(),
        not println()).  The default version gets the atom from
        toStringForHumans().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printNode(ec.EvolutionState, int, int)"><!-- --></A><H3>
printNode</H3>
<PRE>
public int <B>printNode</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                     int&nbsp;log,
                     int&nbsp;verbosity)</PRE>
<DL>
<DD>Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).  The default version gets the atom from toString().
        O(1).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printNode(ec.EvolutionState, java.io.PrintWriter)"><!-- --></A><H3>
printNode</H3>
<PRE>
public int <B>printNode</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                     java.io.PrintWriter&nbsp;writer)</PRE>
<DL>
<DD>Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).  The default version gets the atom from toString().
        O(1).
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toString()"><!-- --></A><H3>
toString</H3>
<PRE>
public abstract java.lang.String <B>toString</B>()</PRE>
<DL>
<DD>Returns a Lisp-like atom for the node which can be read in again by computer.
        If you need to encode an integer or a float or whatever for some reason
        (perhaps if it's an ERC), you should use the ec.util.Code library.
<P>
<DD><DL>
<DT><B>Overrides:</B><DD><CODE>toString</CODE> in class <CODE>java.lang.Object</CODE></DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toStringForHumans()"><!-- --></A><H3>
toStringForHumans</H3>
<PRE>
public java.lang.String <B>toStringForHumans</B>()</PRE>
<DL>
<DD>Returns a Lisp-like atom for the node which is intended for human
        consumption, and not to be read in again.  The default version
        just calls toString().
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="toStringForError()"><!-- --></A><H3>
toStringForError</H3>
<PRE>
public java.lang.String <B>toStringForError</B>()</PRE>
<DL>
<DD>Returns a description of the node that can make it easy to identify
        in error messages (by default, at least its name and the tree it's found in).
        It's okay if this is a reasonably expensive procedure -- it won't be called
        a lot.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeGraphvizTree()"><!-- --></A><H3>
makeGraphvizTree</H3>
<PRE>
public java.lang.String <B>makeGraphvizTree</B>()</PRE>
<DL>
<DD>Produces the Graphviz code for a Graphviz tree of the subtree rooted at this node.
        For this to work, the output of toString() must not contain a double-quote. 
        Note that this isn't particularly efficient and should only be used to generate
        occasional trees for display, not for storing individuals or sending them over networks.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeGraphvizSubtree(java.lang.String)"><!-- --></A><H3>
makeGraphvizSubtree</H3>
<PRE>
protected java.lang.String <B>makeGraphvizSubtree</B>(java.lang.String&nbsp;prefix)</PRE>
<DL>
<DD>Produces the inner code for a graphviz subtree.  Called from makeGraphvizTree(). 
        Note that this isn't particularly efficient and should only be used to generate
        occasional trees for display, not for storing individuals or sending them over networks.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeLatexTree()"><!-- --></A><H3>
makeLatexTree</H3>
<PRE>
public java.lang.String <B>makeLatexTree</B>()</PRE>
<DL>
<DD>Produces the LaTeX code for a LaTeX tree of the subtree rooted at this node, using the <tt>epic</tt>
        and <tt>fancybox</tt> packages, as described in sections 10.5.2 (page 307) 
        and 10.1.3 (page 278) of <i>The LaTeX Companion</i>, respectively.  For this to
        work, the output of toStringForHumans() must not contain any weird latex characters, notably { or } or % or \,
        unless you know what you're doing. See the documentation for ec.gp.GPTree for information
        on how to take this code snippet and insert it into your LaTeX file. 
        Note that this isn't particularly efficient and should only be used to generate
        occasional trees for display, not for storing individuals or sending them over networks.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeCTree(boolean, boolean, boolean)"><!-- --></A><H3>
makeCTree</H3>
<PRE>
public java.lang.String <B>makeCTree</B>(boolean&nbsp;parentMadeParens,
                                  boolean&nbsp;printTerminalsAsVariables,
                                  boolean&nbsp;useOperatorForm)</PRE>
<DL>
<DD>Producess a String consisting of the tree in pseudo-C form, given that the parent already will wrap the
        expression in parentheses (or not).  In pseudo-C form, functions with one child are printed out as a(b), 
        functions with more than two children are printed out as a(b, c, d, ...), and functions with exactly two
        children are either printed as a(b, c) or in operator form as (b a c) -- for example, (b * c).  Whether
        or not to do this depends on the setting of <tt>useOperatorForm</tt>.  Additionally, terminals will be
        printed out either in variable form -- a -- or in zero-argument function form -- a() -- depending on
        the setting of <tt>printTerminalsAsVariables</tt>.
        Note that this isn't particularly efficient and should only be used to generate
        occasional trees for display, not for storing individuals or sending them over networks.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="makeLispTree()"><!-- --></A><H3>
makeLispTree</H3>
<PRE>
public java.lang.String <B>makeLispTree</B>()</PRE>
<DL>
<DD>Produces a tree for human consumption in Lisp form similar to that generated by printTreeForHumans().
       Note that this isn't particularly efficient and should only be used to generate
       occasional trees for display, not for storing individuals or sending them over networks.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRootedTree(ec.EvolutionState, int, int, int)"><!-- --></A><H3>
printRootedTree</H3>
<PRE>
public int <B>printRootedTree</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                           int&nbsp;log,
                           int&nbsp;verbosity,
                           int&nbsp;printbytes)</PRE>
<DL>
<DD>Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer. O(n).  
        You should call this method with printbytes == 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRootedTree(ec.EvolutionState, java.io.PrintWriter, int)"><!-- --></A><H3>
printRootedTree</H3>
<PRE>
public int <B>printRootedTree</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                           java.io.PrintWriter&nbsp;writer,
                           int&nbsp;printbytes)</PRE>
<DL>
<DD>Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer. O(n).  Returns the number of bytes printed.
        You should call this method with printbytes == 0.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="printRootedTreeForHumans(ec.EvolutionState, int, int, int, int)"><!-- --></A><H3>
printRootedTreeForHumans</H3>
<PRE>
public int <B>printRootedTreeForHumans</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                                    int&nbsp;log,
                                    int&nbsp;verbosity,
                                    int&nbsp;tablevel,
                                    int&nbsp;printbytes)</PRE>
<DL>
<DD>Prints out the tree in a readable Lisp-like multi-line fashion. O(n).  You should call this method with tablevel and printbytes == 0.  No ending '\n' is printed.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="readNode(ec.util.DecodeReturn)"><!-- --></A><H3>
readNode</H3>
<PRE>
public <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>readNode</B>(<A HREF="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</A>&nbsp;dret)</PRE>
<DL>
<DD>Reads the node symbol,
        advancing the DecodeReturn to the first character in the string
        beyond the node symbol, and returns a new, empty GPNode of the
        appropriate class representing that symbol, else null if the
        node symbol is not of the correct type for your GPNode class. You may
        assume that initial whitespace has been eliminated.  Generally should
        be case-SENSITIVE, unlike in Lisp.  The default
        version usually works for "simple" function names, that is, not ERCs
        or other stuff where you have to encode the symbol.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="writeRootedTree(ec.EvolutionState, ec.gp.GPType, ec.gp.GPFunctionSet, java.io.DataOutput)"><!-- --></A><H3>
writeRootedTree</H3>
<PRE>
public void <B>writeRootedTree</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                            <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A>&nbsp;expectedType,
                            <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
                            java.io.DataOutput&nbsp;dataOutput)
                     throws java.io.IOException</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="readRootedTree(ec.EvolutionState, java.io.DataInput, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int)"><!-- --></A><H3>
readRootedTree</H3>
<PRE>
public static <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>readRootedTree</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                                    java.io.DataInput&nbsp;dataInput,
                                    <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A>&nbsp;expectedType,
                                    <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
                                    <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A>&nbsp;parent,
                                    int&nbsp;argposition)
                             throws java.io.IOException</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="writeNode(ec.EvolutionState, java.io.DataOutput)"><!-- --></A><H3>
writeNode</H3>
<PRE>
public void <B>writeNode</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                      java.io.DataOutput&nbsp;dataOutput)
               throws java.io.IOException</PRE>
<DL>
<DD>Override this to write any additional node-specific information to dataOutput besides: the number of arguments, 
        the specific node class, the children, and the parent.  The default version of this method does nothing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="readNode(ec.EvolutionState, java.io.DataInput)"><!-- --></A><H3>
readNode</H3>
<PRE>
public void <B>readNode</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                     java.io.DataInput&nbsp;dataInput)
              throws java.io.IOException</PRE>
<DL>
<DD>Override this to read any additional node-specific information from dataInput besides: the number of arguments,
        the specific node class, the children, and the parent.  The default version of this method does nothing.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE>java.io.IOException</CODE></DL>
</DD>
</DL>
<HR>

<A NAME="readRootedTree(int, ec.util.DecodeReturn, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int, ec.EvolutionState)"><!-- --></A><H3>
readRootedTree</H3>
<PRE>
public static <A HREF="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</A> <B>readRootedTree</B>(int&nbsp;linenumber,
                                    <A HREF="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</A>&nbsp;dret,
                                    <A HREF="../../ec/gp/GPType.html" title="class in ec.gp">GPType</A>&nbsp;expectedType,
                                    <A HREF="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</A>&nbsp;set,
                                    <A HREF="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</A>&nbsp;parent,
                                    int&nbsp;argposition,
                                    <A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state)</PRE>
<DL>
<DD>Reads the node and its children from the form printed out by printRootedTree.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="eval(ec.EvolutionState, int, ec.gp.GPData, ec.gp.ADFStack, ec.gp.GPIndividual, ec.Problem)"><!-- --></A><H3>
eval</H3>
<PRE>
public abstract void <B>eval</B>(<A HREF="../../ec/EvolutionState.html" title="class in ec">EvolutionState</A>&nbsp;state,
                          int&nbsp;thread,
                          <A HREF="../../ec/gp/GPData.html" title="class in ec.gp">GPData</A>&nbsp;input,
                          <A HREF="../../ec/gp/ADFStack.html" title="class in ec.gp">ADFStack</A>&nbsp;stack,
                          <A HREF="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</A>&nbsp;individual,
                          <A HREF="../../ec/Problem.html" title="class in ec">Problem</A>&nbsp;problem)</PRE>
<DL>
<DD>Evaluates the node with the given thread, state, individual, problem, and stack.
        Your random number generator will be state.random[thread].  
        The node should, as appropriate, evaluate child nodes with these same items
        passed to eval(...).

        <p>About <b>input</b>: <tt>input</tt> is special; it is how data is passed between
        parent and child nodes.  If children "receive" data from their parent node when
        it evaluates them, they should receive this data stored in <tt>input</tt>.
        If (more likely) the parent "receives" results from its children, it should
        pass them an <tt>input</tt> object, which they'll fill out, then it should
        check this object for the returned value.

        <p>A tree is typically evaluated by dropping a GPData into the root.  When the
        root returns, the resultant <tt>input</tt> should hold the return value.

        <p>In general, you should not be creating new GPDatas.  
        If you think about it, in most conditions (excepting ADFs and ADMs) you 
        can use and reuse <tt>input</tt> for most communications purposes between
        parents and children.  

        <p>So, let's say that your GPNode function implements the boolean AND function,
        and expects its children to return return boolean values (as it does itself).
        You've implemented your GPData subclass to be, uh, <b>BooleanData</b>, which
        looks like 

 <tt><pre>public class BooleanData extends GPData 
    {
    public boolean result;
    public GPData copyTo(GPData gpd)
      {
      ((BooleanData)gpd).result = result;
      }
    }</pre></tt>

        <p>...so, you might implement your eval(...) function as follows:

 <tt><pre>public void eval(final EvolutionState state,
                     final int thread,
                     final GPData input,
                     final ADFStack stack,
                     final GPIndividual individual,
                     final Problem problem
    {
    BooleanData dat = (BooleanData)input;
    boolean x;

    // evaluate the first child
    children[0].eval(state,thread,input,stack,individual,problem);
  
    // store away its result
    x = dat.result;

    // evaluate the second child
    children[1].eval(state,thread,input,stack,individual,problem);

    // return (in input) the result of the two ANDed

    dat.result = dat.result && x;
    return;
    }
        </pre></tt>
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../ec/gp/GPInitializer.html" title="class in ec.gp"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../ec/gp/GPNodeBuilder.html" title="class in ec.gp"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html?ec/gp/GPNode.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GPNode.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
