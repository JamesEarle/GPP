<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (version 1.7.0_51) on Fri Jun 19 12:54:59 EDT 2015 -->
<title>GPNode</title>
<meta name="date" content="2015-06-19">
<link rel="stylesheet" type="text/css" href="../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GPNode";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../ec/gp/GPInitializer.html" title="class in ec.gp"><span class="strong">Prev Class</span></a></li>
<li><a href="../../ec/gp/GPNodeBuilder.html" title="class in ec.gp"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?ec/gp/GPNode.html" target="_top">Frames</a></li>
<li><a href="GPNode.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">ec.gp</div>
<h2 title="Class GPNode" class="title">Class GPNode</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>ec.gp.GPNode</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a>, <a href="../../ec/Prototype.html" title="interface in ec">Prototype</a>, <a href="../../ec/Setup.html" title="interface in ec">Setup</a>, java.io.Serializable, java.lang.Cloneable</dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../ec/gp/ADF.html" title="class in ec.gp">ADF</a>, <a href="../../ec/gp/ADFArgument.html" title="class in ec.gp">ADFArgument</a>, <a href="../../ec/gp/ERC.html" title="class in ec.gp">ERC</a>, <a href="../../ec/gp/push/Nonterminal.html" title="class in ec.gp.push">Nonterminal</a></dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="strong">GPNode</span>
extends java.lang.Object
implements <a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a>, <a href="../../ec/Prototype.html" title="interface in ec">Prototype</a></pre>
<div class="block">GPNode is a GPNodeParent which is the abstract superclass of
 all GP function nodes in trees.  GPNode contains quite a few functions
 for cloning subtrees in special ways, counting the number of nodes
 in subtrees in special ways, and finding specific nodes in subtrees.

 GPNode's lightClone() method does not clone its children (it copies the
 array, but that's it).  If you want to deep-clone a tree or subtree, you
 should use one of the cloneReplacing(...) methods instead.

 <p>GPNodes contain a number of important items:
 <ul><li>A <i>constraints</i> object which defines the name of the node,
 its arity, and its type constraints. This
 object is shared with all GPNodes of the same function name/arity/returntype/childtypes.
 <li>A <i>parent</i>.  This is either another GPNode, or (if this node
 is the root) a GPTree.
 <li>Zero or more <i>children</i>, which are GPNodes.
 <li>An argument position in its parent.
 </ul>


 <p>In addition to serialization for checkpointing, GPNodes may read and write themselves to streams in three ways.

 <ul>
 <li><b>writeNode(...,DataOutput)/readNode(...,DataInput)</b>&nbsp;&nbsp;&nbsp;This method
 transmits or receives a GPNode in binary.  It is the most efficient approach to sending
 GPNodes over networks, etc.  The default versions of writeNode/readNode both generate errors.
 GPNode subclasses should override them to provide more functionality, particularly if you're planning on using
 ECJ in a distributed fashion.  Both of these functions are called by GPNode's readRootedTree/writeRootedTree
 respectively, which handle the reading/printing of the trees as a whole.

 <li><b>printNode(...,PrintWriter)/readNode(...,LineNumberReader)</b>&nbsp;&nbsp;&nbsp;This
 approach transmits or receives a GPNode in text encoded such that the GPNode is largely readable
 by humans but can be read back in 100% by ECJ as well.  To do this, these methods will typically encode numbers
 using the <tt>ec.util.Code</tt> class.  These methods are mostly used to write out populations to
 files for inspection, slight modification, then reading back in later on.  Both of these functions are called by GPNode's readRootedTree/writeRootedTree
 respectively, which handle the reading/printing of the trees as a whole.  Notably readRootedNode
 will try to determine what kind of node is next, then call <b>readNode</b> on the prototype for that
 node to generate the node.  <b>printNode</b> by default calls toString() and
 prints the result, though subclasses often override this to provide additional functionality (notably
 ERCs).

 <li><b>printNodeForHumans(...,PrintWriter)</b>&nbsp;&nbsp;&nbsp;This
 approach prints a GPNode in a fashion intended for human consumption only.
 <b>printNodeForHumans</b> by default calls toStringForHumans() (which by default calls toString()) and
 prints the result.  printNodeForHumans is called by <b>printRootedTreeForHumans</b>, which handles
 printing of the entire GPNode tree.
 </ul>


 <p><b>Parameters</b><br>
 <table>
 <tr><td valign=top><i>base</i>.<tt>nc</tt><br>
 <font size=-1>String</font></td>
 <td valign=top>(name of the node constraints for the GPNode)</td></tr>
 </table>

 <p><b>Default Base</b><br>
 gp.node</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../serialized-form.html#ec.gp.GPNode">Serialized Form</a></dd></dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>byte</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#argposition">argposition</a></strong></code>
<div class="block">The argument position of the child in its parent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[]</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#children">children</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#CHILDREN_UNKNOWN">CHILDREN_UNKNOWN</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>byte</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#constraints">constraints</a></strong></code>
<div class="block">The GPNode's constraints.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#GPNODEPRINTTAB">GPNODEPRINTTAB</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#MAXPRINTBYTES">MAXPRINTBYTES</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#NODESEARCH_ALL">NODESEARCH_ALL</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#NODESEARCH_NONTERMINALS">NODESEARCH_NONTERMINALS</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#NODESEARCH_TERMINALS">NODESEARCH_TERMINALS</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#P_NODE">P_NODE</a></strong></code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#P_NODECONSTRAINTS">P_NODECONSTRAINTS</a></strong></code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#parent">parent</a></strong></code>
<div class="block">The GPNode's parent.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../ec/gp/GPNode.html#GPNode()">GPNode</a></strong>()</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#atDepth()">atDepth</a></strong>()</code>
<div class="block">Returns the depth at which I appear in the tree, which is a value >= 0.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#checkConstraints(ec.EvolutionState, int, ec.gp.GPIndividual, ec.util.Parameter)">checkConstraints</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                int&nbsp;tree,
                <a href="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</a>&nbsp;typicalIndividual,
                <a href="../../ec/util/Parameter.html" title="class in ec.util">Parameter</a>&nbsp;individualBase)</code>
<div class="block">You ought to override this method to check to make sure that the
        constraints are valid as best you can tell.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.Object</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#clone()">clone</a></strong>()</code>
<div class="block">Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#cloneReplacing()">cloneReplacing</a></strong>()</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>use clone() instead.</i></div>
</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#cloneReplacing(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacing</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[]&nbsp;newSubtrees,
              <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[]&nbsp;oldSubtrees)</code>
<div class="block">Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#cloneReplacing(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacing</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;newSubtree,
              <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;oldSubtree)</code>
<div class="block">Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#cloneReplacingAtomic(ec.gp.GPNode[], ec.gp.GPNode[])">cloneReplacingAtomic</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[]&nbsp;newNodes,
                    <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[]&nbsp;oldNodes)</code>
<div class="block">Clones a new subtree, but with each node in oldNodes[] respectively
        (which may or may not be in the subtree) replaced with
        the equivalent
        nodes in newNodes[] (and not clones).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#cloneReplacingAtomic(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingAtomic</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;newNode,
                    <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;oldNode)</code>
<div class="block">Clones a new subtree, but with the single node oldNode 
        (which may or may not be in the subtree) 
        replaced with a newNode (not a clone of newNode).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#cloneReplacingNoSubclone(ec.gp.GPNode, ec.gp.GPNode)">cloneReplacingNoSubclone</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;newSubtree,
                        <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;oldSubtree)</code>
<div class="block">Deep-clones the tree rooted at this node, and returns the entire
        copied tree.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNodeConstraints.html" title="class in ec.gp">GPNodeConstraints</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#constraints(ec.gp.GPInitializer)">constraints</a></strong>(<a href="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</a>&nbsp;initializer)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#contains(ec.gp.GPNode)">contains</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;subnode)</code>
<div class="block">Returns true if the subtree rooted at this node contains subnode.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../ec/util/Parameter.html" title="class in ec.util">Parameter</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#defaultBase()">defaultBase</a></strong>()</code>
<div class="block">The default base for GPNodes -- defined even though
        GPNode is abstract so you don't have to in subclasses.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#depth()">depth</a></strong>()</code>
<div class="block">Returns the depth of the tree, which is a value >= 1.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#errorInfo()">errorInfo</a></strong>()</code>
<div class="block">A convenience function for identifying a GPNode in an error message</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#eval(ec.EvolutionState, int, ec.gp.GPData, ec.gp.ADFStack, ec.gp.GPIndividual, ec.Problem)">eval</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
    int&nbsp;thread,
    <a href="../../ec/gp/GPData.html" title="class in ec.gp">GPData</a>&nbsp;input,
    <a href="../../ec/gp/ADFStack.html" title="class in ec.gp">ADFStack</a>&nbsp;stack,
    <a href="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</a>&nbsp;individual,
    <a href="../../ec/Problem.html" title="class in ec">Problem</a>&nbsp;problem)</code>
<div class="block">Evaluates the node with the given thread, state, individual, problem, and stack.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#expectedChildren()">expectedChildren</a></strong>()</code>
<div class="block">Returns the number of children this node expects to have.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Iterator</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#iterator()">iterator</a></strong>()</code>
<div class="block">Returns an iterator over all the GPNodes in the subtree rooted by this GPNode.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.util.Iterator</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#iterator(ec.gp.GPNodeGatherer)">iterator</a></strong>(<a href="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</a>&nbsp;g)</code>
<div class="block">Returns an iterator over all the GPNodes in the subtree rooted by this GPNode,
        filtered by the provided GPNodeGatherer.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.util.Iterator</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#iterator(int)">iterator</a></strong>(int&nbsp;nodesearch)</code>
<div class="block">Returns an iterator over all the GPNodes in the subtree rooted by this GPNode,
        filtered by the provided nodesearch option (either NODSEARCH_TERMINALS, NODESEARCH_NONTERMINALS, 
        or NODESEARCH_ALL)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#lightClone()">lightClone</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#makeCTree(boolean, boolean, boolean)">makeCTree</a></strong>(boolean&nbsp;parentMadeParens,
         boolean&nbsp;printTerminalsAsVariables,
         boolean&nbsp;useOperatorForm)</code>
<div class="block">Producess a String consisting of the tree in pseudo-C form, given that the parent already will wrap the
        expression in parentheses (or not).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#makeGraphvizSubtree(java.lang.String)">makeGraphvizSubtree</a></strong>(java.lang.String&nbsp;prefix)</code>
<div class="block">Produces the inner code for a graphviz subtree.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#makeGraphvizTree()">makeGraphvizTree</a></strong>()</code>
<div class="block">Produces the Graphviz code for a Graphviz tree of the subtree rooted at this node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#makeLatexTree()">makeLatexTree</a></strong>()</code>
<div class="block">Produces the LaTeX code for a LaTeX tree of the subtree rooted at this node, using the <tt>epic</tt>
        and <tt>fancybox</tt> packages, as described in sections 10.5.2 (page 307) 
        and 10.1.3 (page 278) of <i>The LaTeX Companion</i>, respectively.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#makeLispTree()">makeLispTree</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.StringBuilder</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#makeLispTree(java.lang.StringBuilder)">makeLispTree</a></strong>(java.lang.StringBuilder&nbsp;buf)</code>
<div class="block">Produces a tree for human consumption in Lisp form similar to that generated by printTreeForHumans().</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#name()">name</a></strong>()</code>
<div class="block">Returns a Lisp-like atom for the node and any nodes of the same class.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#nodeEquals(ec.gp.GPNode)">nodeEquals</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;node)</code>
<div class="block">Returns true if I am the "genetically" identical to this node, and our
        children arrays are the same length, though
        we may have different parents and children.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#nodeEquivalentTo(ec.gp.GPNode)">nodeEquivalentTo</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;node)</code>
<div class="block">Returns true if I and the provided node are the same kind of
        node -- that is, we could have both been cloned() and reset() from
        the same prototype node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#nodeHashCode()">nodeHashCode</a></strong>()</code>
<div class="block">Returns a hashcode usually associated with all nodes that are 
        equal to you (using nodeEquals(...)).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#nodeInPosition(int, ec.gp.GPNodeGatherer)">nodeInPosition</a></strong>(int&nbsp;p,
              <a href="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</a>&nbsp;g)</code>
<div class="block">Returns the p'th node, constrained by nodesearch,
        in the subtree for which this GPNode is root.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#nodeInPosition(int, int)">nodeInPosition</a></strong>(int&nbsp;p,
              int&nbsp;nodesearch)</code>
<div class="block">Returns the p'th node, constrained by nodesearch,
        in the subtree for which this GPNode is root.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#numNodes(ec.gp.GPNodeGatherer)">numNodes</a></strong>(<a href="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</a>&nbsp;g)</code>
<div class="block">Returns the number of nodes, constrained by g.test(...)
        in the subtree for which this GPNode is root.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#numNodes(int)">numNodes</a></strong>(int&nbsp;nodesearch)</code>
<div class="block">Returns the number of nodes, constrained by nodesearch,
        in the subtree for which this GPNode is root.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../ec/gp/GPType.html" title="class in ec.gp">GPType</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#parentType(ec.gp.GPInitializer)">parentType</a></strong>(<a href="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</a>&nbsp;initializer)</code>
<div class="block">Returns the argument type of the slot that I fit into in my parent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#pathLength(int)">pathLength</a></strong>(int&nbsp;nodesearch)</code>
<div class="block">Returns the path length of the tree, which is the sum of all paths from all nodes to the root.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printNode(ec.EvolutionState, int)">printNode</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
         int&nbsp;log)</code>
<div class="block">Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printNode(ec.EvolutionState, int, int)">printNode</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
         int&nbsp;log,
         int&nbsp;verbosity)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>Verbosity no longer has an effect.</i></div>
</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printNode(ec.EvolutionState, java.io.PrintWriter)">printNode</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
         java.io.PrintWriter&nbsp;writer)</code>
<div class="block">Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printNodeForHumans(ec.EvolutionState, int)">printNodeForHumans</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                  int&nbsp;log)</code>
<div class="block">Prints out a human-readable and Lisp-like atom for the node, 
        and returns the number of bytes in the string that you sent
        to the log (use print(),
        not println()).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printNodeForHumans(ec.EvolutionState, int, int)">printNodeForHumans</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                  int&nbsp;log,
                  int&nbsp;verbosity)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>Verbosity no longer has an effect.</i></div>
</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printRootedTree(ec.EvolutionState, int, int)">printRootedTree</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
               int&nbsp;log,
               int&nbsp;printbytes)</code>
<div class="block">Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printRootedTree(ec.EvolutionState, int, int, int)">printRootedTree</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
               int&nbsp;log,
               int&nbsp;verbosity,
               int&nbsp;printbytes)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>Verbosity no longer has an effect.</i></div>
</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printRootedTree(ec.EvolutionState, java.io.PrintWriter, int)">printRootedTree</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
               java.io.PrintWriter&nbsp;writer,
               int&nbsp;printbytes)</code>
<div class="block">Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printRootedTreeForHumans(ec.EvolutionState, int, int, int)">printRootedTreeForHumans</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                        int&nbsp;log,
                        int&nbsp;tablevel,
                        int&nbsp;printbytes)</code>
<div class="block">Prints out the tree in a readable Lisp-like multi-line fashion.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#printRootedTreeForHumans(ec.EvolutionState, int, int, int, int)">printRootedTreeForHumans</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                        int&nbsp;log,
                        int&nbsp;verbosity,
                        int&nbsp;tablevel,
                        int&nbsp;printbytes)</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>Verbosity no longer has an effect.</i></div>
</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#readNode(ec.util.DecodeReturn)">readNode</a></strong>(<a href="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</a>&nbsp;dret)</code>
<div class="block">Reads the node symbol,
        advancing the DecodeReturn to the first character in the string
        beyond the node symbol, and returns a new, empty GPNode of the
        appropriate class representing that symbol, else null if the
        node symbol is not of the correct type for your GPNode class.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#readNode(ec.EvolutionState, java.io.DataInput)">readNode</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
        java.io.DataInput&nbsp;dataInput)</code>
<div class="block">Override this to read any additional node-specific information from dataInput besides: the number of arguments,
        the specific node class, the children, and the parent.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#readRootedTree(ec.EvolutionState, java.io.DataInput, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int)">readRootedTree</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
              java.io.DataInput&nbsp;dataInput,
              <a href="../../ec/gp/GPType.html" title="class in ec.gp">GPType</a>&nbsp;expectedType,
              <a href="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</a>&nbsp;set,
              <a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a>&nbsp;parent,
              int&nbsp;argposition)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#readRootedTree(int, ec.util.DecodeReturn, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int, ec.EvolutionState)">readRootedTree</a></strong>(int&nbsp;linenumber,
              <a href="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</a>&nbsp;dret,
              <a href="../../ec/gp/GPType.html" title="class in ec.gp">GPType</a>&nbsp;expectedType,
              <a href="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</a>&nbsp;set,
              <a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a>&nbsp;parent,
              int&nbsp;argposition,
              <a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state)</code>
<div class="block">Reads the node and its children from the form printed out by printRootedTree.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#replaceWith(ec.gp.GPNode)">replaceWith</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;newNode)</code>
<div class="block">Replaces the node with another node in its position in the tree.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#resetNode(ec.EvolutionState, int)">resetNode</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
         int&nbsp;thread)</code>
<div class="block">Starts a node in a new life immediately after it has been cloned.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#rootedTreeEquals(ec.gp.GPNode)">rootedTreeEquals</a></strong>(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;node)</code>
<div class="block">Returns true if the two rooted trees are "genetically" equal, though
        they may have different parents.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#rootedTreeHashCode()">rootedTreeHashCode</a></strong>()</code>
<div class="block">Returns a hashcode associated with all the nodes in the tree.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a></code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#rootParent()">rootParent</a></strong>()</code>
<div class="block">Returns the root ancestor of this node.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
     <a href="../../ec/util/Parameter.html" title="class in ec.util">Parameter</a>&nbsp;base)</code>
<div class="block">Sets up a <i>prototypical</i> GPNode with those features all nodes of that
        prototype share, and nothing more.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#swapCompatibleWith(ec.gp.GPInitializer, ec.gp.GPNode)">swapCompatibleWith</a></strong>(<a href="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</a>&nbsp;initializer,
                  <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;node)</code>
<div class="block">Returns true if I can swap into node's position.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#toString()">toString</a></strong>()</code>
<div class="block">Returns a Lisp-like atom for the node which can be read in again by computer.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#toStringForError()">toStringForError</a></strong>()</code>
<div class="block">Returns a description of the node that can make it easy to identify
        in error messages (by default, at least its name and the tree it's found in).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>java.lang.String</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#toStringForHumans()">toStringForHumans</a></strong>()</code>
<div class="block">Returns a Lisp-like atom for the node which is intended for human
        consumption, and not to be read in again.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#writeNode(ec.EvolutionState, java.io.DataOutput)">writeNode</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
         java.io.DataOutput&nbsp;dataOutput)</code>
<div class="block">Override this to write any additional node-specific information to dataOutput besides: the number of arguments, 
        the specific node class, the children, and the parent.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../ec/gp/GPNode.html#writeRootedTree(ec.EvolutionState, ec.gp.GPType, ec.gp.GPFunctionSet, java.io.DataOutput)">writeRootedTree</a></strong>(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
               <a href="../../ec/gp/GPType.html" title="class in ec.gp">GPType</a>&nbsp;expectedType,
               <a href="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</a>&nbsp;set,
               java.io.DataOutput&nbsp;dataOutput)</code>&nbsp;</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>equals, finalize, getClass, hashCode, notify, notifyAll, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="P_NODE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>P_NODE</h4>
<pre>public static final&nbsp;java.lang.String P_NODE</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#ec.gp.GPNode.P_NODE">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="P_NODECONSTRAINTS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>P_NODECONSTRAINTS</h4>
<pre>public static final&nbsp;java.lang.String P_NODECONSTRAINTS</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#ec.gp.GPNode.P_NODECONSTRAINTS">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="GPNODEPRINTTAB">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>GPNODEPRINTTAB</h4>
<pre>public static final&nbsp;java.lang.String GPNODEPRINTTAB</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#ec.gp.GPNode.GPNODEPRINTTAB">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="MAXPRINTBYTES">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>MAXPRINTBYTES</h4>
<pre>public static final&nbsp;int MAXPRINTBYTES</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#ec.gp.GPNode.MAXPRINTBYTES">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="NODESEARCH_ALL">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NODESEARCH_ALL</h4>
<pre>public static final&nbsp;int NODESEARCH_ALL</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#ec.gp.GPNode.NODESEARCH_ALL">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="NODESEARCH_TERMINALS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NODESEARCH_TERMINALS</h4>
<pre>public static final&nbsp;int NODESEARCH_TERMINALS</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#ec.gp.GPNode.NODESEARCH_TERMINALS">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="NODESEARCH_NONTERMINALS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>NODESEARCH_NONTERMINALS</h4>
<pre>public static final&nbsp;int NODESEARCH_NONTERMINALS</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#ec.gp.GPNode.NODESEARCH_NONTERMINALS">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="CHILDREN_UNKNOWN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CHILDREN_UNKNOWN</h4>
<pre>public static final&nbsp;int CHILDREN_UNKNOWN</pre>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../constant-values.html#ec.gp.GPNode.CHILDREN_UNKNOWN">Constant Field Values</a></dd></dl>
</li>
</ul>
<a name="parent">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parent</h4>
<pre>public&nbsp;<a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a> parent</pre>
<div class="block">The GPNode's parent.  4 bytes.  :-(  But it really helps simplify breeding.</div>
</li>
</ul>
<a name="children">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>children</h4>
<pre>public&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[] children</pre>
</li>
</ul>
<a name="argposition">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>argposition</h4>
<pre>public&nbsp;byte argposition</pre>
<div class="block">The argument position of the child in its parent. 
        This is a byte to save space (GPNode is the critical object space-wise) -- 
        besides, how often do you have 256 children? You can change this to a short
        or int easily if you absolutely need to.  It's possible to eliminate even
        this and have the child find itself in its parent, but that's an O(children[])
        operation, and probably not inlinable, so I figure a byte is okay.</div>
</li>
</ul>
<a name="constraints">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>constraints</h4>
<pre>public&nbsp;byte constraints</pre>
<div class="block">The GPNode's constraints.  This is a byte to save space -- how often do
        you have 256 different GPNodeConstraints?  Well, I guess it's not infeasible.
        You can increase this to an int without much trouble.  You typically 
        shouldn't access the constraints through this variable -- use the constraints(state)
        method instead.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="GPNode()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>GPNode</h4>
<pre>public&nbsp;GPNode()</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="constraints(ec.gp.GPInitializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>constraints</h4>
<pre>public final&nbsp;<a href="../../ec/gp/GPNodeConstraints.html" title="class in ec.gp">GPNodeConstraints</a>&nbsp;constraints(<a href="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</a>&nbsp;initializer)</pre>
</li>
</ul>
<a name="defaultBase()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>defaultBase</h4>
<pre>public&nbsp;<a href="../../ec/util/Parameter.html" title="class in ec.util">Parameter</a>&nbsp;defaultBase()</pre>
<div class="block">The default base for GPNodes -- defined even though
        GPNode is abstract so you don't have to in subclasses.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../ec/Prototype.html#defaultBase()">defaultBase</a></code>&nbsp;in interface&nbsp;<code><a href="../../ec/Prototype.html" title="interface in ec">Prototype</a></code></dd>
</dl>
</li>
</ul>
<a name="checkConstraints(ec.EvolutionState, int, ec.gp.GPIndividual, ec.util.Parameter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>checkConstraints</h4>
<pre>public&nbsp;void&nbsp;checkConstraints(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                    int&nbsp;tree,
                    <a href="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</a>&nbsp;typicalIndividual,
                    <a href="../../ec/util/Parameter.html" title="class in ec.util">Parameter</a>&nbsp;individualBase)</pre>
<div class="block">You ought to override this method to check to make sure that the
        constraints are valid as best you can tell.  Things you might
        check for:

        <ul>
        <li> children.length is correct
        <li> certain arguments in constraints.childtypes are 
        swap-compatible with each other
        <li> constraints.returntype is swap-compatible with appropriate 
        arguments in constraints.childtypes
        </ul>

        You can't check for everything, of course, but you might try some
        obvious checks for blunders.  The default version of this method
        simply calls numChildren() if it's defined (it returns something >= 0).
        If the value doesn't match the current number of children, an error is raised.
        This is a simple constraints check.

        The ultimate caller of this method must guarantee that he will eventually
        call state.output.exitIfErrors(), so you can freely use state.output.error
        instead of state.output.fatal(), which will help a lot.

        Warning: this method may get called more than once.</div>
</li>
</ul>
<a name="expectedChildren()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>expectedChildren</h4>
<pre>public&nbsp;int&nbsp;expectedChildren()</pre>
<div class="block">Returns the number of children this node expects to have.  This method is
        only called by the default implementation of checkConstraints(...), and by default
        it returns CHILDREN_UNKNOWN.  You can override this method to return a value >= 0,
        which will be checked for in the default checkConstraints(...), or you can leave
        this method alone and override checkConstraints(...) to check for more complex constraints
        as you see fit.</div>
</li>
</ul>
<a name="setup(ec.EvolutionState, ec.util.Parameter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setup</h4>
<pre>public&nbsp;void&nbsp;setup(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
         <a href="../../ec/util/Parameter.html" title="class in ec.util">Parameter</a>&nbsp;base)</pre>
<div class="block">Sets up a <i>prototypical</i> GPNode with those features all nodes of that
        prototype share, and nothing more.  So no filled-in children, 
        no argposition, no parent.  Yet.

        This must be called <i>after</i> the GPTypes and GPNodeConstraints 
        have been set up.  Presently they're set up in GPInitializer,
        which gets called before this does, so we're safe. 

        You should override this if you need to load some special features on
        a per-function basis.  Note that base hangs off of a function set, so
        this method may get called for different instances in the same GPNode
        class if they're being set up as prototypes for different GPFunctionSets.

        If you absolutely need some global base, then you should use something
        hanging off of GPDefaults.base().

        The ultimate caller of this method must guarantee that he will eventually
        call state.output.exitIfErrors(), so you can freely use state.output.error
        instead of state.output.fatal(), which will help a lot.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../ec/Prototype.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</a></code>&nbsp;in interface&nbsp;<code><a href="../../ec/Prototype.html" title="interface in ec">Prototype</a></code></dd>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../ec/Setup.html#setup(ec.EvolutionState, ec.util.Parameter)">setup</a></code>&nbsp;in interface&nbsp;<code><a href="../../ec/Setup.html" title="interface in ec">Setup</a></code></dd>
</dl>
</li>
</ul>
<a name="parentType(ec.gp.GPInitializer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>parentType</h4>
<pre>public final&nbsp;<a href="../../ec/gp/GPType.html" title="class in ec.gp">GPType</a>&nbsp;parentType(<a href="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</a>&nbsp;initializer)</pre>
<div class="block">Returns the argument type of the slot that I fit into in my parent.  
        If I'm the root, returns the treetype of the GPTree.</div>
</li>
</ul>
<a name="swapCompatibleWith(ec.gp.GPInitializer, ec.gp.GPNode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>swapCompatibleWith</h4>
<pre>public final&nbsp;boolean&nbsp;swapCompatibleWith(<a href="../../ec/gp/GPInitializer.html" title="class in ec.gp">GPInitializer</a>&nbsp;initializer,
                         <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;node)</pre>
<div class="block">Returns true if I can swap into node's position.</div>
</li>
</ul>
<a name="numNodes(ec.gp.GPNodeGatherer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>numNodes</h4>
<pre>public&nbsp;int&nbsp;numNodes(<a href="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</a>&nbsp;g)</pre>
<div class="block">Returns the number of nodes, constrained by g.test(...)
        in the subtree for which this GPNode is root.  This might
        be sped up by caching the value.  O(n).</div>
</li>
</ul>
<a name="numNodes(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>numNodes</h4>
<pre>public&nbsp;int&nbsp;numNodes(int&nbsp;nodesearch)</pre>
<div class="block">Returns the number of nodes, constrained by nodesearch,
        in the subtree for which this GPNode is root.
        This might be sped up by cacheing the value somehow.  O(n).</div>
</li>
</ul>
<a name="depth()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>depth</h4>
<pre>public&nbsp;int&nbsp;depth()</pre>
<div class="block">Returns the depth of the tree, which is a value >= 1.  O(n).</div>
</li>
</ul>
<a name="pathLength(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pathLength</h4>
<pre>public&nbsp;int&nbsp;pathLength(int&nbsp;nodesearch)</pre>
<div class="block">Returns the path length of the tree, which is the sum of all paths from all nodes to the root.   O(n).</div>
</li>
</ul>
<a name="atDepth()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>atDepth</h4>
<pre>public&nbsp;int&nbsp;atDepth()</pre>
<div class="block">Returns the depth at which I appear in the tree, which is a value >= 0. O(ln n) avg.</div>
</li>
</ul>
<a name="iterator(ec.gp.GPNodeGatherer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterator</h4>
<pre>public&nbsp;java.util.Iterator&nbsp;iterator(<a href="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</a>&nbsp;g)</pre>
<div class="block">Returns an iterator over all the GPNodes in the subtree rooted by this GPNode,
        filtered by the provided GPNodeGatherer.</div>
</li>
</ul>
<a name="iterator(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterator</h4>
<pre>public&nbsp;java.util.Iterator&nbsp;iterator(int&nbsp;nodesearch)</pre>
<div class="block">Returns an iterator over all the GPNodes in the subtree rooted by this GPNode,
        filtered by the provided nodesearch option (either NODSEARCH_TERMINALS, NODESEARCH_NONTERMINALS, 
        or NODESEARCH_ALL)</div>
</li>
</ul>
<a name="iterator()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>iterator</h4>
<pre>public&nbsp;java.util.Iterator&nbsp;iterator()</pre>
<div class="block">Returns an iterator over all the GPNodes in the subtree rooted by this GPNode.</div>
</li>
</ul>
<a name="nodeInPosition(int, ec.gp.GPNodeGatherer)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodeInPosition</h4>
<pre>public&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;nodeInPosition(int&nbsp;p,
                    <a href="../../ec/gp/GPNodeGatherer.html" title="class in ec.gp">GPNodeGatherer</a>&nbsp;g)</pre>
<div class="block">Returns the p'th node, constrained by nodesearch,
        in the subtree for which this GPNode is root.
        Use numNodes(nodesearch) to determine the total number.  
        g.test(...) is used as the constraining predicate.
        p ranges from 0 to this number minus 1. O(n). The
        resultant node is returned in <i>g</i>.</div>
</li>
</ul>
<a name="nodeInPosition(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodeInPosition</h4>
<pre>public&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;nodeInPosition(int&nbsp;p,
                    int&nbsp;nodesearch)</pre>
<div class="block">Returns the p'th node, constrained by nodesearch,
        in the subtree for which this GPNode is root.
        Use numNodes(nodesearch) to determine the total number.  
        g.test(...) is used as the constraining predicate.
        p ranges from 0 to this number minus 1. O(n). The
        resultant node is returned in <i>g</i>.</div>
</li>
</ul>
<a name="rootParent()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rootParent</h4>
<pre>public&nbsp;<a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a>&nbsp;rootParent()</pre>
<div class="block">Returns the root ancestor of this node.  O(ln n) average case,
        O(n) worst case.</div>
</li>
</ul>
<a name="contains(ec.gp.GPNode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>contains</h4>
<pre>public&nbsp;boolean&nbsp;contains(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;subnode)</pre>
<div class="block">Returns true if the subtree rooted at this node contains subnode.  O(n).</div>
</li>
</ul>
<a name="resetNode(ec.EvolutionState, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetNode</h4>
<pre>public&nbsp;void&nbsp;resetNode(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
             int&nbsp;thread)</pre>
<div class="block">Starts a node in a new life immediately after it has been cloned.
        The default version of this function does nothing.  The purpose of
        this function is to give ERCs a chance to set themselves to a new
        random value after they've been cloned from the prototype.
        You should not assume that the node is properly connected to other
        nodes in the tree at the point this method is called.</div>
</li>
</ul>
<a name="errorInfo()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>errorInfo</h4>
<pre>public&nbsp;java.lang.String&nbsp;errorInfo()</pre>
<div class="block">A convenience function for identifying a GPNode in an error message</div>
</li>
</ul>
<a name="lightClone()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lightClone</h4>
<pre>public&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;lightClone()</pre>
</li>
</ul>
<a name="clone()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>clone</h4>
<pre>public&nbsp;java.lang.Object&nbsp;clone()</pre>
<div class="block">Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  The result has everything set except for the root
        node's parent and argposition.  This method is identical to
        cloneReplacing for historical reasons, except that it returns
        the object as an Object, not a GPNode.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../ec/Prototype.html#clone()">clone</a></code>&nbsp;in interface&nbsp;<code><a href="../../ec/Prototype.html" title="interface in ec">Prototype</a></code></dd>
<dt><strong>Overrides:</strong></dt>
<dd><code>clone</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="cloneReplacing()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cloneReplacing</h4>
<pre>public final&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;cloneReplacing()</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>use clone() instead.</i></div>
<div class="block">Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  The result has everything set except for the root
        node's parent and argposition.  This method is identical to
        cloneReplacing for historical reasons, except that it returns
        the object as a GPNode, not an Object.</div>
</li>
</ul>
<a name="cloneReplacing(ec.gp.GPNode, ec.gp.GPNode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cloneReplacing</h4>
<pre>public final&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;cloneReplacing(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;newSubtree,
                    <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;oldSubtree)</pre>
<div class="block">Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If the node oldSubtree is located somewhere in this
        tree, then its subtree is replaced with a deep-cloned copy of
        newSubtree.  The result has everything set except for the root
        node's parent and argposition.</div>
</li>
</ul>
<a name="cloneReplacingNoSubclone(ec.gp.GPNode, ec.gp.GPNode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cloneReplacingNoSubclone</h4>
<pre>public final&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;cloneReplacingNoSubclone(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;newSubtree,
                              <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;oldSubtree)</pre>
<div class="block">Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If the node oldSubtree is located somewhere in this
        tree, then its subtree is replaced with
        newSubtree (<i>not</i> a copy of newSubtree).  
        The result has everything set except for the root
        node's parent and argposition.</div>
</li>
</ul>
<a name="cloneReplacing(ec.gp.GPNode[], ec.gp.GPNode[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cloneReplacing</h4>
<pre>public final&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;cloneReplacing(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[]&nbsp;newSubtrees,
                    <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[]&nbsp;oldSubtrees)</pre>
<div class="block">Deep-clones the tree rooted at this node, and returns the entire
        copied tree.  If a node in oldSubtrees is located somewhere in this
        tree, then its subtree is replaced with a deep-cloned copy of the
        subtree rooted at its equivalent number in 
        newSubtrees.  The result has everything set except for the root
        node's parent and argposition.</div>
</li>
</ul>
<a name="cloneReplacingAtomic(ec.gp.GPNode, ec.gp.GPNode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cloneReplacingAtomic</h4>
<pre>public final&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;cloneReplacingAtomic(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;newNode,
                          <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;oldNode)</pre>
<div class="block">Clones a new subtree, but with the single node oldNode 
        (which may or may not be in the subtree) 
        replaced with a newNode (not a clone of newNode).  
        These nodes should be
        type-compatible both in argument and return types, and should have
        the same number of arguments obviously.  This function will <i>not</i>
        check for this, and if they are not the result is undefined.</div>
</li>
</ul>
<a name="cloneReplacingAtomic(ec.gp.GPNode[], ec.gp.GPNode[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cloneReplacingAtomic</h4>
<pre>public final&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;cloneReplacingAtomic(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[]&nbsp;newNodes,
                          <a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>[]&nbsp;oldNodes)</pre>
<div class="block">Clones a new subtree, but with each node in oldNodes[] respectively
        (which may or may not be in the subtree) replaced with
        the equivalent
        nodes in newNodes[] (and not clones).  
        The length of oldNodes[] and newNodes[] should
        be the same of course.  These nodes should be
        type-compatible both in argument and return types, and should have
        the same number of arguments obviously.  This function will <i>not</i>
        check for this, and if they are not the result is undefined.</div>
</li>
</ul>
<a name="replaceWith(ec.gp.GPNode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>replaceWith</h4>
<pre>public final&nbsp;void&nbsp;replaceWith(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;newNode)</pre>
<div class="block">Replaces the node with another node in its position in the tree. 
        newNode should already have been cloned and ready to go.
        We presume that the other node is type-compatible and
        of the same arity (these things aren't checked).</div>
</li>
</ul>
<a name="nodeEquivalentTo(ec.gp.GPNode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodeEquivalentTo</h4>
<pre>public&nbsp;boolean&nbsp;nodeEquivalentTo(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;node)</pre>
<div class="block">Returns true if I and the provided node are the same kind of
        node -- that is, we could have both been cloned() and reset() from
        the same prototype node.  The default form of this function returns
        true if I and the node have the same class, the same length children
        array, and the same constraints.  You may wish to override this in
        certain circumstances.   Here's an example of how nodeEquivalentTo(node)
        differs from nodeEquals(node): two ERCs, both of
        the same class, but one holding '1.23' and the other holding '2.45', which
        came from the same prototype node in the same function set.
        They should NOT be nodeEquals(...) but *should* be nodeEquivalent(...).</div>
</li>
</ul>
<a name="nodeHashCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodeHashCode</h4>
<pre>public&nbsp;int&nbsp;nodeHashCode()</pre>
<div class="block">Returns a hashcode usually associated with all nodes that are 
        equal to you (using nodeEquals(...)).  The default form
        of this method returns the hashcode of the node's class.
        ERCs in particular probably will want to override this method.</div>
</li>
</ul>
<a name="rootedTreeHashCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rootedTreeHashCode</h4>
<pre>public&nbsp;int&nbsp;rootedTreeHashCode()</pre>
<div class="block">Returns a hashcode associated with all the nodes in the tree.  
        The default version adds the hash of the node plus its child
        trees, rotated one-off each time, which seems reasonable.</div>
</li>
</ul>
<a name="nodeEquals(ec.gp.GPNode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodeEquals</h4>
<pre>public&nbsp;boolean&nbsp;nodeEquals(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;node)</pre>
<div class="block">Returns true if I am the "genetically" identical to this node, and our
        children arrays are the same length, though
        we may have different parents and children.  The default form
        of this method simply calls the much weaker nodeEquivalentTo(node).  
        You may need to override this to perform exact comparisons, if you're
        an ERC, ADF, or ADM for example.  Here's an example of how nodeEquivalentTo(node)
        differs from nodeEquals(node): two ERCs, both of
        the same class, but one holding '1.23' and the other holding '2.45', which
        came from the same prototype node in the same function set.
        They should NOT be nodeEquals(...) but *should* be nodeEquivalent(...).</div>
</li>
</ul>
<a name="rootedTreeEquals(ec.gp.GPNode)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rootedTreeEquals</h4>
<pre>public&nbsp;boolean&nbsp;rootedTreeEquals(<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;node)</pre>
<div class="block">Returns true if the two rooted trees are "genetically" equal, though
        they may have different parents.  O(n).</div>
</li>
</ul>
<a name="printNodeForHumans(ec.EvolutionState, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printNodeForHumans</h4>
<pre>public&nbsp;int&nbsp;printNodeForHumans(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                     int&nbsp;log)</pre>
<div class="block">Prints out a human-readable and Lisp-like atom for the node, 
        and returns the number of bytes in the string that you sent
        to the log (use print(),
        not println()).  The default version gets the atom from
        toStringForHumans().</div>
</li>
</ul>
<a name="printNodeForHumans(ec.EvolutionState, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printNodeForHumans</h4>
<pre>public&nbsp;int&nbsp;printNodeForHumans(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                     int&nbsp;log,
                     int&nbsp;verbosity)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>Verbosity no longer has an effect.</i></div>
<div class="block">Prints out a human-readable and Lisp-like atom for the node, 
        and returns the number of bytes in the string that you sent
        to the log (use print(),
        not println()).  The default version gets the atom from
        toStringForHumans().</div>
</li>
</ul>
<a name="printNode(ec.EvolutionState, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printNode</h4>
<pre>public&nbsp;int&nbsp;printNode(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
            int&nbsp;log)</pre>
<div class="block">Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).  The default version gets the atom from toString().
        O(1).</div>
</li>
</ul>
<a name="printNode(ec.EvolutionState, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printNode</h4>
<pre>public&nbsp;int&nbsp;printNode(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
            int&nbsp;log,
            int&nbsp;verbosity)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>Verbosity no longer has an effect.</i></div>
<div class="block">Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).  The default version gets the atom from toString().
        O(1).</div>
</li>
</ul>
<a name="printNode(ec.EvolutionState, java.io.PrintWriter)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printNode</h4>
<pre>public&nbsp;int&nbsp;printNode(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
            java.io.PrintWriter&nbsp;writer)</pre>
<div class="block">Prints out a COMPUTER-readable and Lisp-like atom for the node, which
        is also suitable for readNode to read, and returns
        the number of bytes in the string that you sent to the log (use print(),
        not println()).  The default version gets the atom from toString().
        O(1).</div>
</li>
</ul>
<a name="name()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>name</h4>
<pre>public&nbsp;java.lang.String&nbsp;name()</pre>
<div class="block">Returns a Lisp-like atom for the node and any nodes of the same class.
        This will almost always be identical to the result of toString() (and the default
        does exactly this), but for ERCs it'll be different: toString will include the
        encoded constant data, whereas name() will not include this information and will
        be the same for all ERCs of this type.  If two nodes are nodeEquivalentTo(...)
        each other, then they will have the same name().  If two nodes are nodeEquals(...)
        each other, then they will have the same toString().</div>
</li>
</ul>
<a name="toString()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toString</h4>
<pre>public abstract&nbsp;java.lang.String&nbsp;toString()</pre>
<div class="block">Returns a Lisp-like atom for the node which can be read in again by computer.
        If you need to encode an integer or a float or whatever for some reason
        (perhaps if it's an ERC), you should use the ec.util.Code library.</div>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code>toString</code>&nbsp;in class&nbsp;<code>java.lang.Object</code></dd>
</dl>
</li>
</ul>
<a name="toStringForHumans()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStringForHumans</h4>
<pre>public&nbsp;java.lang.String&nbsp;toStringForHumans()</pre>
<div class="block">Returns a Lisp-like atom for the node which is intended for human
        consumption, and not to be read in again.  The default version
        just calls toString().</div>
</li>
</ul>
<a name="toStringForError()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>toStringForError</h4>
<pre>public&nbsp;java.lang.String&nbsp;toStringForError()</pre>
<div class="block">Returns a description of the node that can make it easy to identify
        in error messages (by default, at least its name and the tree it's found in).
        It's okay if this is a reasonably expensive procedure -- it won't be called
        a lot.</div>
</li>
</ul>
<a name="makeGraphvizTree()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeGraphvizTree</h4>
<pre>public&nbsp;java.lang.String&nbsp;makeGraphvizTree()</pre>
<div class="block">Produces the Graphviz code for a Graphviz tree of the subtree rooted at this node.
        For this to work, the output of toString() must not contain a double-quote. 
        Note that this isn't particularly efficient and should only be used to generate
        occasional trees for display, not for storing individuals or sending them over networks.</div>
</li>
</ul>
<a name="makeGraphvizSubtree(java.lang.String)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeGraphvizSubtree</h4>
<pre>protected&nbsp;java.lang.String&nbsp;makeGraphvizSubtree(java.lang.String&nbsp;prefix)</pre>
<div class="block">Produces the inner code for a graphviz subtree.  Called from makeGraphvizTree(). 
        Note that this isn't particularly efficient and should only be used to generate
        occasional trees for display, not for storing individuals or sending them over networks.</div>
</li>
</ul>
<a name="makeLatexTree()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeLatexTree</h4>
<pre>public&nbsp;java.lang.String&nbsp;makeLatexTree()</pre>
<div class="block">Produces the LaTeX code for a LaTeX tree of the subtree rooted at this node, using the <tt>epic</tt>
        and <tt>fancybox</tt> packages, as described in sections 10.5.2 (page 307) 
        and 10.1.3 (page 278) of <i>The LaTeX Companion</i>, respectively.  For this to
        work, the output of toStringForHumans() must not contain any weird latex characters, notably { or } or % or \,
        unless you know what you're doing. See the documentation for ec.gp.GPTree for information
        on how to take this code snippet and insert it into your LaTeX file. 
        Note that this isn't particularly efficient and should only be used to generate
        occasional trees for display, not for storing individuals or sending them over networks.</div>
</li>
</ul>
<a name="makeCTree(boolean, boolean, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeCTree</h4>
<pre>public&nbsp;java.lang.String&nbsp;makeCTree(boolean&nbsp;parentMadeParens,
                         boolean&nbsp;printTerminalsAsVariables,
                         boolean&nbsp;useOperatorForm)</pre>
<div class="block">Producess a String consisting of the tree in pseudo-C form, given that the parent already will wrap the
        expression in parentheses (or not).  In pseudo-C form, functions with one child are printed out as a(b), 
        functions with more than two children are printed out as a(b, c, d, ...), and functions with exactly two
        children are either printed as a(b, c) or in operator form as (b a c) -- for example, (b * c).  Whether
        or not to do this depends on the setting of <tt>useOperatorForm</tt>.  Additionally, terminals will be
        printed out either in variable form -- a -- or in zero-argument function form -- a() -- depending on
        the setting of <tt>printTerminalsAsVariables</tt>.
        Note that this isn't particularly efficient and should only be used to generate
        occasional trees for display, not for storing individuals or sending them over networks.</div>
</li>
</ul>
<a name="makeLispTree(java.lang.StringBuilder)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeLispTree</h4>
<pre>public&nbsp;java.lang.StringBuilder&nbsp;makeLispTree(java.lang.StringBuilder&nbsp;buf)</pre>
<div class="block">Produces a tree for human consumption in Lisp form similar to that generated by printTreeForHumans().
       Note that this isn't particularly efficient and should only be used to generate
       occasional trees for display, not for storing individuals or sending them over networks.</div>
</li>
</ul>
<a name="makeLispTree()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeLispTree</h4>
<pre>public&nbsp;java.lang.String&nbsp;makeLispTree()</pre>
</li>
</ul>
<a name="printRootedTree(ec.EvolutionState, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printRootedTree</h4>
<pre>public&nbsp;int&nbsp;printRootedTree(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                  int&nbsp;log,
                  int&nbsp;printbytes)</pre>
<div class="block">Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer. O(n).  
        You should call this method with printbytes == 0.</div>
</li>
</ul>
<a name="printRootedTree(ec.EvolutionState, int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printRootedTree</h4>
<pre>public&nbsp;int&nbsp;printRootedTree(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                  int&nbsp;log,
                  int&nbsp;verbosity,
                  int&nbsp;printbytes)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>Verbosity no longer has an effect.</i></div>
<div class="block">Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer. O(n).  
        You should call this method with printbytes == 0.</div>
</li>
</ul>
<a name="printRootedTree(ec.EvolutionState, java.io.PrintWriter, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printRootedTree</h4>
<pre>public&nbsp;int&nbsp;printRootedTree(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                  java.io.PrintWriter&nbsp;writer,
                  int&nbsp;printbytes)</pre>
<div class="block">Prints out the tree on a single line, with no ending \n, in a fashion that can
        be read in later by computer. O(n).  Returns the number of bytes printed.
        You should call this method with printbytes == 0.</div>
</li>
</ul>
<a name="printRootedTreeForHumans(ec.EvolutionState, int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printRootedTreeForHumans</h4>
<pre>public&nbsp;int&nbsp;printRootedTreeForHumans(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                           int&nbsp;log,
                           int&nbsp;tablevel,
                           int&nbsp;printbytes)</pre>
<div class="block">Prints out the tree in a readable Lisp-like multi-line fashion. O(n).  
        You should call this method with tablevel and printbytes == 0.  
        No ending '\n' is printed.</div>
</li>
</ul>
<a name="printRootedTreeForHumans(ec.EvolutionState, int, int, int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>printRootedTreeForHumans</h4>
<pre>public&nbsp;int&nbsp;printRootedTreeForHumans(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                           int&nbsp;log,
                           int&nbsp;verbosity,
                           int&nbsp;tablevel,
                           int&nbsp;printbytes)</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>Verbosity no longer has an effect.</i></div>
<div class="block">Prints out the tree in a readable Lisp-like multi-line fashion. O(n).  
        You should call this method with tablevel and printbytes == 0.  
        No ending '\n' is printed.</div>
</li>
</ul>
<a name="readNode(ec.util.DecodeReturn)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readNode</h4>
<pre>public&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;readNode(<a href="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</a>&nbsp;dret)</pre>
<div class="block">Reads the node symbol,
        advancing the DecodeReturn to the first character in the string
        beyond the node symbol, and returns a new, empty GPNode of the
        appropriate class representing that symbol, else null if the
        node symbol is not of the correct type for your GPNode class. You may
        assume that initial whitespace has been eliminated.  Generally should
        be case-SENSITIVE, unlike in Lisp.  The default
        version usually works for "simple" function names, that is, not ERCs
        or other stuff where you have to encode the symbol.</div>
</li>
</ul>
<a name="writeRootedTree(ec.EvolutionState, ec.gp.GPType, ec.gp.GPFunctionSet, java.io.DataOutput)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeRootedTree</h4>
<pre>public&nbsp;void&nbsp;writeRootedTree(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                   <a href="../../ec/gp/GPType.html" title="class in ec.gp">GPType</a>&nbsp;expectedType,
                   <a href="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</a>&nbsp;set,
                   java.io.DataOutput&nbsp;dataOutput)
                     throws java.io.IOException</pre>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="readRootedTree(ec.EvolutionState, java.io.DataInput, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readRootedTree</h4>
<pre>public static&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;readRootedTree(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
                    java.io.DataInput&nbsp;dataInput,
                    <a href="../../ec/gp/GPType.html" title="class in ec.gp">GPType</a>&nbsp;expectedType,
                    <a href="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</a>&nbsp;set,
                    <a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a>&nbsp;parent,
                    int&nbsp;argposition)
                             throws java.io.IOException</pre>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="writeNode(ec.EvolutionState, java.io.DataOutput)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>writeNode</h4>
<pre>public&nbsp;void&nbsp;writeNode(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
             java.io.DataOutput&nbsp;dataOutput)
               throws java.io.IOException</pre>
<div class="block">Override this to write any additional node-specific information to dataOutput besides: the number of arguments, 
        the specific node class, the children, and the parent.  The default version of this method does nothing.</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="readNode(ec.EvolutionState, java.io.DataInput)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readNode</h4>
<pre>public&nbsp;void&nbsp;readNode(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
            java.io.DataInput&nbsp;dataInput)
              throws java.io.IOException</pre>
<div class="block">Override this to read any additional node-specific information from dataInput besides: the number of arguments,
        the specific node class, the children, and the parent.  The default version of this method does nothing.</div>
<dl><dt><span class="strong">Throws:</span></dt>
<dd><code>java.io.IOException</code></dd></dl>
</li>
</ul>
<a name="readRootedTree(int, ec.util.DecodeReturn, ec.gp.GPType, ec.gp.GPFunctionSet, ec.gp.GPNodeParent, int, ec.EvolutionState)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>readRootedTree</h4>
<pre>public static&nbsp;<a href="../../ec/gp/GPNode.html" title="class in ec.gp">GPNode</a>&nbsp;readRootedTree(int&nbsp;linenumber,
                    <a href="../../ec/util/DecodeReturn.html" title="class in ec.util">DecodeReturn</a>&nbsp;dret,
                    <a href="../../ec/gp/GPType.html" title="class in ec.gp">GPType</a>&nbsp;expectedType,
                    <a href="../../ec/gp/GPFunctionSet.html" title="class in ec.gp">GPFunctionSet</a>&nbsp;set,
                    <a href="../../ec/gp/GPNodeParent.html" title="interface in ec.gp">GPNodeParent</a>&nbsp;parent,
                    int&nbsp;argposition,
                    <a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state)</pre>
<div class="block">Reads the node and its children from the form printed out by printRootedTree.</div>
</li>
</ul>
<a name="eval(ec.EvolutionState, int, ec.gp.GPData, ec.gp.ADFStack, ec.gp.GPIndividual, ec.Problem)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>eval</h4>
<pre>public abstract&nbsp;void&nbsp;eval(<a href="../../ec/EvolutionState.html" title="class in ec">EvolutionState</a>&nbsp;state,
        int&nbsp;thread,
        <a href="../../ec/gp/GPData.html" title="class in ec.gp">GPData</a>&nbsp;input,
        <a href="../../ec/gp/ADFStack.html" title="class in ec.gp">ADFStack</a>&nbsp;stack,
        <a href="../../ec/gp/GPIndividual.html" title="class in ec.gp">GPIndividual</a>&nbsp;individual,
        <a href="../../ec/Problem.html" title="class in ec">Problem</a>&nbsp;problem)</pre>
<div class="block">Evaluates the node with the given thread, state, individual, problem, and stack.
        Your random number generator will be state.random[thread].  
        The node should, as appropriate, evaluate child nodes with these same items
        passed to eval(...).

        <p>About <b>input</b>: <tt>input</tt> is special; it is how data is passed between
        parent and child nodes.  If children "receive" data from their parent node when
        it evaluates them, they should receive this data stored in <tt>input</tt>.
        If (more likely) the parent "receives" results from its children, it should
        pass them an <tt>input</tt> object, which they'll fill out, then it should
        check this object for the returned value.

        <p>A tree is typically evaluated by dropping a GPData into the root.  When the
        root returns, the resultant <tt>input</tt> should hold the return value.

        <p>In general, you should not be creating new GPDatas.  
        If you think about it, in most conditions (excepting ADFs and ADMs) you 
        can use and reuse <tt>input</tt> for most communications purposes between
        parents and children.  

        <p>So, let's say that your GPNode function implements the boolean AND function,
        and expects its children to return return boolean values (as it does itself).
        You've implemented your GPData subclass to be, uh, <b>BooleanData</b>, which
        looks like 

 <tt><pre>public class BooleanData extends GPData 
    {
    public boolean result;
    public GPData copyTo(GPData gpd)
      {
      ((BooleanData)gpd).result = result;
      }
    }</pre></tt>

        <p>...so, you might implement your eval(...) function as follows:

 <tt><pre>public void eval(final EvolutionState state,
                     final int thread,
                     final GPData input,
                     final ADFStack stack,
                     final GPIndividual individual,
                     final Problem problem
    {
    BooleanData dat = (BooleanData)input;
    boolean x;

    // evaluate the first child
    children[0].eval(state,thread,input,stack,individual,problem);
  
    // store away its result
    x = dat.result;

    // evaluate the second child
    children[1].eval(state,thread,input,stack,individual,problem);

    // return (in input) the result of the two ANDed

    dat.result = dat.result && x;
    return;
    }
        </pre></tt></div>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../index-all.html">Index</a></li>
<li><a href="../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../ec/gp/GPInitializer.html" title="class in ec.gp"><span class="strong">Prev Class</span></a></li>
<li><a href="../../ec/gp/GPNodeBuilder.html" title="class in ec.gp"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../index.html?ec/gp/GPNode.html" target="_top">Frames</a></li>
<li><a href="GPNode.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</body>
</html>
